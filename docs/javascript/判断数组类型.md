

## [在JavaScript中，如何判断数组是数组？](https://segmentfault.com/a/1190000006150186)

https://segmentfault.com/a/1190000006150186



#### JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法.



#### 1、typeof 



![typeof运算符返回值一览表](https://tva1.sinaimg.cn/large/006tNbRwly1g9tv64doroj30dw094q4m.jpg)

从这张表格可以看出，数组被归到了Any other object当中，所以**<u>typeof返回的结果应该是Object，并没有办法区分数组，对象，null等原型链上都有Object的数据类型。</u>**

```js
const a = null;
const b = {};
const c= [];
console.log(typeof(a)); //Object
console.log(typeof(b)); //Object
console.log(typeof(c)); //Object
```

运行上面的代码就会发现，**<u>在参数为数组，对象或者null时，typeof返回的结果都是object</u>**，可以使用这种方法并不能识别出数组，因此，在JavaScript项目中用typeof来判断一个位置类型的数据是否为数组，是非常不靠谱的。



#### 2.用instanceof判断

instanceof运算符可以用来判断某个构造函数的prototype属性所指向的對象是否存在于另外一个要检测对象的原型链上。在使用的时候语法如下：

```JS
object(这里其实是一个变量) instanceof constructor(这个 constructor 是跑类型，eg，array，object)
```

用我的理解来说，就是要判断一个Object是不是数组（这里不是口误，在JavaScript当中，数组实际上也是一种对象），如果这个Object的原型链上能够找到Array构造函数的话，那么这个Object应该及就是一个数组，如果这个Object的原型链上只能找到Object构造函数的话，那么它就不是一个数组。

```js
const a = [];
const b = {};
console.log(a instanceof Array);//true
console.log(a instanceof Object);//true,在数组的原型链上也能找到Object构造函数
console.log(b instanceof Array);//false
```





#### 3.用constructor判断

**<u>实例化的数组</u>**拥有一个**<u>constructor属性</u>**，**<u>这个属性指向生成这个数组的方法</u>**。

```js
const a = [];
console.log(a.constructor);// 结果 function Array(){ [native code] }
```

以上的代码说明，**<u>数组是有一个叫Array的函数实例化的</u>**。
如果被判断的对象是其他的数据类型的话，结果如下：

```js
const o = {};
console.log(o.constructor);//function Object(){ [native code] }
const r = /^[0-9]$/;
console.log(r.constructor);//function RegExp() { [native code] }
const n = null;
console.log(n.constructor);//报错
```

看到这里，你可能会觉得这也是一种靠谱的判断数组的方法，我们可以用以下的方式来判断:

```JS
const a = [];
console.log(a.constructor == Array);//true
```

但是，很遗憾的通知你，constructor属性是可以改写的，如果你一不小心作死改了constructor属性的话，那么使用这种方法就无法判断出数组的真是身份了，写到这里，我不禁想起了无间道的那段经典对白，梁朝伟：“对不起，我是警察。”刘德华：“谁知道呢？”。

```JS
//定义一个数组
const a = [];
//作死将constructor属性改成了别的
a.contrtuctor = Object;
console.log(a.constructor == Array);//false (哭脸)
console.log(a.constructor == Object);//true (哭脸)
console.log(a instanceof Array);//true (instanceof火眼金睛)
```

**<u>可以看出，constructor属性被修改之后，就无法用这个方法判断数组是数组了，除非你能保证不会发生constructor属性被改写的情况，否则用这种方法来判断数组也是不靠谱的。</u>**



#### 4.用Object的toString方法判断

另一个行之有效的方法就是使用Object.prototype.toString方法来判断，每一个继承自Object的对象都拥有toString的方法。

```JS
// 直接调用 toString() 方法，是不行的

const a = ['Hello','Howard'];
const b = {0:'Hello',1:'Howard'};  // 对象 {} 返回正常
const c = 'Hello Howard';
a.toString();//"Hello,Howard"
b.toString();//"[object Object]"
c.toString();//"Hello,Howard"
```

从上面的代码可以看出，**<u>除了对象之外，其他的数据类型的toString返回的都是内容的字符串，只有对象的toString方法会返回对象的类型。</u>**所以要判断除了对象之外的数据的数据类型，我们需要“借用”对象的toString方法，所以我们**<u>需要使用call或者apply方法来改变toString方法的执行上下文</u>**。



```js
// call
const a = ['Hello','Howard'];
const b = {0:'Hello',1:'Howard'};
const c = 'Hello Howard';
Object.prototype.toString.call(a);//"[object Array]"
Object.prototype.toString.call(b);//"[object Object]"
Object.prototype.toString.call(c);//"[object String]"

// 使用apply方法也能达到同样的效果：
const a = ['Hello','Howard'];
const b = {0:'Hello',1:'Howard'};
const c = 'Hello Howard';
Object.prototype.toString.apply(a);//"[object Array]"
Object.prototype.toString.apply(b);//"[object Object]"
Object.prototype.toString.apply(c);//"[object String]"
```



总结一下，我们就可以用写一个方法来判断数组是否为数组：

```js
const isArray = (something)=>{
    return Object.prototype.toString.call(something) === '[object Array]';
}
cosnt a = [];
const b = {};
isArray(a);//true
isArray(b);//false
```

但是，如果你非要在创建这个方法之前这么来一下，改变了Object原型链上的toString方法，那我真心帮不了你了...

```js
//重写了toString方法
Object.prototype.toString = () => {
    alert('你吃过了么？');
}
//调用String方法
const a = [];
Object.prototype.toString.call(a);//弹框问你吃过饭没有
```



###  <u>**5.用Array对象的isArray方法判断**</u>

为什么把这种方法放在最后讲呢？因为它是我目前遇到过的**<u>最靠谱的判断数组的方法</u>**了，当参数为数组的时候，isArray方法返回true，当参数不为数组的时候，isArray方法返回false。

```js
const a = [];
const b = {};
Array.isArray(a);//true
Array.isArray(b);//false
```

试着在调用这个方法之前重写了Object.prototype.toString方法：

```js
Object.prototype.toString = ()=>{
    console.log('Hello Howard');
}
const a = [];
Array.isArray(a);//true

// 并不影响判断的结果。
// 又试着修改了constructor对象：
const a = [];
const b = {};
a.constructor = b.constructor;
Array.isArray(a);//true
```

可见，它与instance运算符判断的方法以及Object.prototype.toString法并不相同，一些列的修改并没有影响到判断的结果。

你可以放心大胆的使用Array.isArray去判断一个对象是不是数组。
除非你不小心重写了Array.isArray方法本身。。



***

重要补充：有读者朋友在评论中提醒我，Array.isArray是ES5标准中增加的方法，部分比较老的浏览器可能会有兼容问题，所以为了增强健壮性，建议还是给Array.isArray方法进行判断，增强兼容性，重新封装的方法如下：

```js
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
// !Array.isArray 判断是否存在
```









